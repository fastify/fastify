// This file is autogenerated by build/build-error-serializer.js, do not edit
/* istanbul ignore file */
module.exports = $main
    'use strict'
  
    
function $pad2Zeros (num) {
  const s = '00' + num
  return s[s.length - 2] + s[s.length - 1]
}

function $asAny (i) {
  return JSON.stringify(i)
}

function $asNull () {
  return 'null'
}

function $asInteger (i) {
  if (typeof i === 'bigint') {
    return i.toString()
  } else if (Number.isInteger(i)) {
    return $asNumber(i)
  } else {
    /* eslint no-undef: "off" */
    return $asNumber(parseInteger(i))
  }
}

function $asIntegerNullable (i) {
  return i === null ? null : $asInteger(i)
}

function $asNumber (i) {
  const num = Number(i)
  if (isNaN(num)) {
    return 'null'
  } else {
    return '' + num
  }
}

function $asNumberNullable (i) {
  return i === null ? null : $asNumber(i)
}

function $asBoolean (bool) {
  return bool && 'true' || 'false' // eslint-disable-line
}

function $asBooleanNullable (bool) {
  return bool === null ? null : $asBoolean(bool)
}

function $asDatetime (date, skipQuotes) {
  const quotes = skipQuotes === true ? '' : '"'
  if (date instanceof Date) {
    return quotes + date.toISOString() + quotes
  } else if (date && typeof date.toISOString === 'function') {
    return quotes + date.toISOString() + quotes
  } else {
    return $asString(date, skipQuotes)
  }
}

function $asDate (date, skipQuotes) {
  const quotes = skipQuotes === true ? '' : '"'
  if (date instanceof Date) {
    return quotes + new Date(date.getTime() - (date.getTimezoneOffset() * 60000 )).toISOString().slice(0, 10) + quotes
  } else if (date && typeof date.format === 'function') {
    return quotes + date.format('YYYY-MM-DD') + quotes
  } else {
    return $asString(date, skipQuotes)
  }
}

function $asTime (date, skipQuotes) {
  const quotes = skipQuotes === true ? '' : '"'
  if (date instanceof Date) {
    const hour = new Intl.DateTimeFormat('en', { hour: 'numeric', hour12: false }).format(date)
    const minute = new Intl.DateTimeFormat('en', { minute: 'numeric' }).format(date)
    const second = new Intl.DateTimeFormat('en', { second: 'numeric' }).format(date)
    return quotes + $pad2Zeros(hour) + ':' + $pad2Zeros(minute) + ':' + $pad2Zeros(second) + quotes
  } else if (date && typeof date.format === 'function') {
    return quotes + date.format('HH:mm:ss') + quotes
  } else {
    return $asString(date, skipQuotes)
  }
}

function $asString (str, skipQuotes) {
  const quotes = skipQuotes === true ? '' : '"'
  if (str instanceof Date) {
    return quotes + str.toISOString() + quotes
  } else if (str === null) {
    return quotes + quotes
  } else if (str instanceof RegExp) {
    str = str.source
  } else if (typeof str !== 'string') {
    str = str.toString()
  }
  // If we skipQuotes it means that we are using it as test
  // no need to test the string length for the render
  if (skipQuotes) {
    return str
  }

  if (str.length < 42) {
    return $asStringSmall(str)
  } else {
    return JSON.stringify(str)
  }
}

function $asStringNullable (str) {
  return str === null ? null : $asString(str)
}

// magically escape strings for json
// relying on their charCodeAt
// everything below 32 needs JSON.stringify()
// every string that contain surrogate needs JSON.stringify()
// 34 and 92 happens all the time, so we
// have a fast case for them
function $asStringSmall (str) {
  const l = str.length
  let result = ''
  let last = 0
  let found = false
  let surrogateFound = false
  let point = 255
  // eslint-disable-next-line
  for (var i = 0; i < l && point >= 32; i++) {
    point = str.charCodeAt(i)
    if (point >= 0xD800 && point <= 0xDFFF) {
      // The current character is a surrogate.
      surrogateFound = true
    }
    if (point === 34 || point === 92) {
      result += str.slice(last, i) + '\\'
      last = i
      found = true
    }
  }

  if (!found) {
    result = str
  } else {
    result += str.slice(last)
  }
  return ((point < 32) || (surrogateFound === true)) ? JSON.stringify(str) : '"' + result + '"'
}


    
    /**
     * Used by schemas that are dependant on calling 'ajv.validate' during runtime,
     * it stores the value of the '$id' property of the schema (if it has it) inside
     * a cache which is used to figure out if the schema was compiled into a validator
     * by ajv on a previous call, if it was then the '$id' string will be used to 
     * invoke 'ajv.validate', this allows:
     * 
     * 1. Schemas that depend on ajv.validate calls to leverage ajv caching system.
     * 2. To avoid errors, since directly invoking 'ajv.validate' with the same 
     * schema (that contains an '$id' property) twice will throw an error.
     */
    const $validateWithAjv = (function() {
      const cache = new Set()

      return function (schema, target) {
        const id = schema.$id
        
        if (!id) {
          return ajv.validate(schema, target)
        }

        const cached = cache.has(id)

        if (cached) {
          return ajv.validate(id, target)
        } else {
          cache.add(id)
          return ajv.validate(schema, target)
        }
      }
    })()


    function parseInteger(int) { return Math.trunc(int) }
    
    function $main (input) {
  
      var obj = (input && typeof input.toJSON === 'function')
    ? input.toJSON()
    : input
  
      var json = '{'
      var addComma = false
  
          var t = Number(obj["statusCode"])
          if (!isNaN(t)) {
            
  if (addComma) {
    json += ','
  } else {
    addComma = true
  }

            json += "\"statusCode\"" + ':' + t
      
      }
    
        if (obj["code"] !== undefined) {
          
  if (addComma) {
    json += ','
  } else {
    addComma = true
  }

          json += "\"code\"" + ':'
        json += $asString(obj["code"])
      }
    
        if (obj["error"] !== undefined) {
          
  if (addComma) {
    json += ','
  } else {
    addComma = true
  }

          json += "\"error\"" + ':'
        json += $asString(obj["error"])
      }
    
        if (obj["message"] !== undefined) {
          
  if (addComma) {
    json += ','
  } else {
    addComma = true
  }

          json += "\"message\"" + ':'
        json += $asString(obj["message"])
      }
    
      json += '}'
      return json
    }
    
  
    ;
     return $main
  
